<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=//images/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=//images/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=//images/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=//images/apple-touch-icon.png><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css rel=stylesheet><script src=https://cdn.counter.dev/script.js data-id=06a7380e-2356-44ad-8660-5da0df137f3b data-utcoffset=6></script><link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel=stylesheet><script>window.trackerWebsiteId="fb8e3309-4543-48f4-b791-38aef0166f80"</script><script src=https://pagepulse-production.up.railway.app/static/tracker.js></script><meta name=description content="Implement WebSockets in FastAPI, from basic setups for small projects to advanced, scalable solutions for industry-level applications, with practical examples and best practices."><title>WebSockets in FastAPI: From Basics to Scaling | Pawan Chaurasia
</title><link rel=canonical href=/engineering/websocket_in_fast_api/><meta property="og:url" content="/engineering/websocket_in_fast_api/"><meta property="og:site_name" content="Pawan Chaurasia"><meta property="og:title" content="WebSockets in FastAPI: From Basics to Scaling"><meta property="og:description" content="Implement WebSockets in FastAPI, from basic setups for small projects to advanced, scalable solutions for industry-level applications, with practical examples and best practices."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="engineering"><meta property="article:published_time" content="2025-02-18T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-18T00:00:00+00:00"><meta property="article:tag" content="FastAPI"><meta property="article:tag" content="Python"><meta property="article:tag" content="Websocket"><meta property="article:tag" content="Realtime"><meta property="article:tag" content="Redis"><meta property="article:tag" content="RabbitMQ"><link rel=stylesheet href=/assets/combined.min.7375e7927bac3491ad5e04a0baae299a4f9020585680efb72e0a0fda5215c74a.css media=all><script async src="https://www.googletagmanager.com/gtag/js?id=G-xxxxxxxxx"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-xxxxxxxxx")}</script></head><body class=dark><div class=content><header><div class=header><h1 class=header-title><a href=/>Pawan Chaurasia</a></h1><div class=flex><p class=small><a href=/>/HOME</a></p><p class=small><a href=/me>/ME</a></p><p class=small><a href=/engineering>/ENGINEERING</a></p><p class=small><a href=/adventure>/ADVENTURE</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>> </span><a href=/engineering>Engineering</a>
<span class=breadcrumbs-separator>> </span><span class=breadcrumbs-current>WebSockets in FastAPI: From Basics to Scaling</span></div><div><div class=single-intro-container><h1 class=single-title>WebSockets in FastAPI: From Basics to Scaling</h1><p class=single-summary>WebSockets enable real-time, bidirectional communication, perfect for chat apps, live notifications, and gaming. FastAPI, a modern Python framework, makes it easy to implement WebSockets for scalable, real-time applications. This blog walks you through setting up WebSocket connections, handling messages, and managing client-server interactions in FastAPI, with practical examples and best practices.</p><p class=single-readtime><time datetime=2025-02-18T00:00:00+00:00>February 18, 2025</time>
&nbsp; · &nbsp;
15 min read</p></div><div class=single-tags><span><a href=/tags/fastapi/>#FastAPI</a>
</span><span><a href=/tags/python/>#Python</a>
</span><span><a href=/tags/websocket/>#Websocket</a>
</span><span><a href=/tags/realtime/>#Realtime</a>
</span><span><a href=/tags/redis/>#Redis</a>
</span><span><a href=/tags/rabbitmq/>#RabbitMQ</a>
</span><span><a href=/tags/communication/>#Communication</a></span></div><aside class=toc><p><strong>Table of contents</strong></p><nav id=TableOfContents><ul><li><a href=#websocket-and-why-you-should-care>Websocket and Why You Should Care?</a></li><li><a href=#the-setup>The Setup</a><ul><li><ul><li><a href=#step-1-install-fastapi>Step 1: Install FastAPI</a></li><li><a href=#step-1-install-redis>Step 1: Install Redis</a></li><li><a href=#step-3-install-rabbitmq-and-pika-for-rabbitmq>Step 3: Install RabbitMQ and Pika for RabbitMQ</a></li><li><a href=#why-this-setup>Why This Setup?</a></li></ul></li></ul></li><li><a href=#writing-the-code-lets-get-real-time>Writing the Code: Let’s Get Real-Time</a><ul><li><ul><li><a href=#step-1-create-the-fastapi-app>Step 1: Create the FastAPI App</a></li><li><a href=#step-2-run-the-websocket-server>Step 2: Run the WebSocket Server</a></li><li><a href=#step-3-verify-everything-is-working>Step 3: Verify Everything is Working</a></li><li><a href=#step-4-making-the-chat-bidirectional-because-talking-to-yourself-is-weird>Step 4: Making the Chat Bidirectional (Because Talking to Yourself is Weird)</a></li><li><a href=#step-5-how-far-can-we-go-with-this-setup>Step 5: How Far Can We Go with this setup?</a></li></ul></li></ul></li><li><a href=#scaling-up-handling-moderate-traffic>Scaling Up: Handling Moderate Traffic</a><ul><li><ul><li><a href=#why-redis>Why Redis?</a></li><li><a href=#lets-add-redis-connection-manager>Let&rsquo;s Add Redis Connection Manager</a></li><li><a href=#update-the-websocket-endpoint-1>Update the WebSocket Endpoint</a></li><li><a href=#code-breakdown>Code Breakdown</a></li><li><a href=#scaling-with-redis-math-edition>Scaling with Redis (Math Edition)</a></li></ul></li></ul></li><li><a href=#the-dream-scale-handling-thousands-of-users>The Dream Scale: Handling Thousands of Users</a><ul><li><ul><li><a href=#why-rabbitmq>Why RabbitMQ?</a></li><li><a href=#back-of-the-envelope-calculations-1>Back-of-the-Envelope Calculations</a></li><li><a href=#rabbitmq-connection-manager>RabbitMQ Connection Manager</a></li><li><a href=#managed-services-vs-self-hosted>Managed Services vs. Self-Hosted</a></li></ul></li></ul></li><li><a href=#conclusion-real-time-apps-made-simple>Conclusion: Real-Time Apps Made Simple</a><ul><li><ul><li><a href=#what-are-your-thoughts>What Are Your Thoughts?</a></li></ul></li></ul></li></ul></nav></aside><div class=single-content><h2 class=heading id=websocket-and-why-you-should-care>Websocket and Why You Should Care?
<a href=#websocket-and-why-you-should-care>#</a></h2><p>Let’s talk about WebSockets. If HTTP is like sending letters (write, wait, receive, repeat), WebSockets are like a never-ending phone call. They allow real-time, bidirectional communication between a client and a server, meaning both can send and receive data instantly without waiting for requests.</p><p>Technically, WebSockets are a protocol that provides full-duplex communication over a single, long-lived connection. Unlike HTTP, which is stateless and requires a new request for every response, WebSockets keep the connection alive. This makes them perfect for:</p><ul><li>Chat apps (because no one likes waiting for “…” to turn into a message).</li><li>Live notifications (because FOMO is real).</li><li>Real-time data sharing (like the app we’re building in this blog).</li></ul><p>I’m building a real-time location-sharing app for my motorcycle riding group. One of the key features is sharing live locations (with consent, of course). No more lying to the admins when you say, “I’m about to reach,” while you’re still stuck in Silk Board traffic. (Pro tip: You should’ve started early.)</p><p>To make this happen, I’m using FastAPI (Python) for the backend because it’s fast, async, and just plain awesome. For handling moderate scale, I’m using Redis to keep things snappy with its in-memory data storage. And for large-scale scenarios (fingers crossed, I hope my app gets so popular that I’ll have this “good problem” to solve), I’ll bring in RabbitMQ for message brokering. It’s my way of future-proofing the app, just in case.</p><p>In this blog, we’ll go from “Hey, I connected two things!” to “OMG, I’m handling thousands of users without breaking a sweat!” So, grab a coffee (or a beer, no one’s judging), and let’s get started.</p><h2 class=heading id=the-setup>The Setup
<a href=#the-setup>#</a></h2><p>Before we dive into the code, let’s get our tools ready. We’ll need FastAPI for the backend, Redis for handling real-time data, and Pika for working with RabbitMQ later.</p><h4 class=heading id=step-1-install-fastapi>Step 1: Install FastAPI
<a href=#step-1-install-fastapi>#</a></h4><p>FastAPI is the backbone of our app. It’s fast, async, and ridiculously easy to use. Let’s install it along with uvicorn and websockets, an ASGI server to run our app:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pip install fastapi uvicorn websockets
</span></span></code></pre></div><h4 class=heading id=step-1-install-redis>Step 1: Install Redis
<a href=#step-1-install-redis>#</a></h4><p>Redis is perfect for real-time data handling. It’s fast, in-memory, and works like a charm for our use case. Let’s install the Redis Python client:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pip install redis
</span></span></code></pre></div><p><em>Pro tip: If you don’t have Redis installed on your system, just search for <span class=span_highlight>How to set up Redis on [your OS]</span> (Linux, Mac, Windows, etc.). It’s straightforward, and there are plenty of guides out there!</em></p><h4 class=heading id=step-3-install-rabbitmq-and-pika-for-rabbitmq>Step 3: Install RabbitMQ and Pika for RabbitMQ
<a href=#step-3-install-rabbitmq-and-pika-for-rabbitmq>#</a></h4><p>For scaling to thousands of users, we’ll use RabbitMQ. To interact with it in Python, we’ll use Pika:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pip install pika
</span></span></code></pre></div><p><em>Pro tip: If you don’t have RabbitMQ installed on your system, just search for <span class=span_highlight>How to set up RabbitMQ on [your OS]</span> (Linux, Mac, Windows, etc.). It’s straightforward, and there are plenty of guides out there!</em></p><h4 class=heading id=why-this-setup>Why This Setup?
<a href=#why-this-setup>#</a></h4><ul><li><span class=span_highlight>FastAPI:</span> Because it’s fast, modern, and perfect for real-time apps.</li><li><span class=span_highlight>Redis:</span> For in-memory data storage and real-time updates.</li><li><span class=span_highlight>RabbitMQ:</span> To handle message brokering when we scale (because dreams do come true, right?).</li></ul><h2 class=heading id=writing-the-code-lets-get-real-time>Writing the Code: Let’s Get Real-Time
<a href=#writing-the-code-lets-get-real-time>#</a></h2><p>Let’s start by writing some code! We’ll set up a basic FastAPI app, serve an HTML page on the root route, and run a WebSocket server.</p><h4 class=heading id=step-1-create-the-fastapi-app>Step 1: Create the FastAPI App
<a href=#step-1-create-the-fastapi-app>#</a></h4><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#586e75># main.py</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> fastapi <span style=color:#719e07>import</span> FastAPI, WebSocket
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> fastapi.responses <span style=color:#719e07>import</span> HTMLResponse
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#719e07>=</span> FastAPI()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75># Serve an HTML page on the root route</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>@app.get</span>(<span style=color:#2aa198>&#34;/&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>get</span>():
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> HTMLResponse(<span style=color:#2aa198>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    &lt;html&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        &lt;head&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            &lt;title&gt;Real-Time Data Sharing&lt;/title&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        &lt;/head&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        &lt;body&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            &lt;h1&gt;Welcome to the Real-Time App!&lt;/h1&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            &lt;div id=&#34;chat&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                &lt;input type=&#34;text&#34; id=&#34;message&#34; placeholder=&#34;Type a message...&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                &lt;button onclick=&#34;sendMessage()&#34;&gt;Send&lt;/button&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            &lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            &lt;ul id=&#34;messages&#34;&gt;&lt;/ul&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            &lt;script&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                // Generate a random username (e.g., &#34;AnonymousXYZ&#34;)
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                const generateUsername = () =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                    const randomPart = Math.random().toString(36).substring(2, 5).toUpperCase();
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                    return `Anonymous$</span><span style=color:#2aa198>{randomPart}</span><span style=color:#2aa198>`;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                };
</span></span></span><span style=display:flex><span><span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                const username = generateUsername(); // Assign a random username
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                const ws = new WebSocket(&#34;ws://localhost:8081/ws&#34;);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                // Function to send a message
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                const sendMessage = () =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                    const message = document.getElementById(&#34;message&#34;).value.trim();
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                    if (message === &#34;&#34;) return; // Prevent sending empty messages
</span></span></span><span style=display:flex><span><span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                    ws.send(`$</span><span style=color:#2aa198>{username}</span><span style=color:#2aa198>: $</span><span style=color:#2aa198>{message}</span><span style=color:#2aa198>`);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                    document.getElementById(&#34;message&#34;).value = &#34;&#34;; // Clear the input box
</span></span></span><span style=display:flex><span><span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                };
</span></span></span><span style=display:flex><span><span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                // Display incoming messages
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                ws.onmessage = (event) =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                    const messages = document.getElementById(&#34;messages&#34;);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                    const li = document.createElement(&#34;li&#34;);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                    li.textContent = event.data;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                    messages.appendChild(li);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                };
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            &lt;/script&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        &lt;/body&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    &lt;/html&gt;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>&#34;&#34;&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#586e75># Run the app</span>
</span></span><span style=display:flex><span><span style=color:#719e07>if</span> __name__ <span style=color:#719e07>==</span> <span style=color:#2aa198>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    <span style=color:#719e07>import</span> uvicorn
</span></span><span style=display:flex><span>    uvicorn<span style=color:#719e07>.</span>run(app, host<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;0.0.0.0&#34;</span>, port<span style=color:#719e07>=</span><span style=color:#2aa198>8080</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#586e75># web_socket.py</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> fastapi <span style=color:#719e07>import</span> FastAPI, WebSocket
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> fastapi.responses <span style=color:#719e07>import</span> HTMLResponse
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#719e07>=</span> FastAPI()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75># WebSocket endpoint</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>@app.websocket</span>(<span style=color:#2aa198>&#34;/ws&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>websocket_endpoint</span>(websocket: WebSocket):
</span></span><span style=display:flex><span>    <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>accept()
</span></span><span style=display:flex><span>    <span style=color:#b58900>print</span>(<span style=color:#2aa198>&#34;INFO: WebSocket connection established&#34;</span>)  <span style=color:#586e75># Log connection</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>while</span> <span style=color:#cb4b16>True</span>:
</span></span><span style=display:flex><span>        data <span style=color:#719e07>=</span> <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>receive_text()
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;INFO: Received: </span><span style=color:#2aa198>{</span>data<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)  <span style=color:#586e75># Log received message</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>send_text(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;</span><span style=color:#2aa198>{</span>data<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)  <span style=color:#586e75># Broadcast the message</span>
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;INFO: Sent: </span><span style=color:#2aa198>{</span>data<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)  <span style=color:#586e75># Log sent message</span>
</span></span></code></pre></div><h4 class=heading id=step-2-run-the-websocket-server>Step 2: Run the WebSocket Server
<a href=#step-2-run-the-websocket-server>#</a></h4><p>Since WebSockets need to run indefinitely, we’ll run the WebSocket server on a different port (8081). This avoids potential conflicts and makes debugging easier.</p><h5 class=heading id=running-the-http-server-port-8080>Running the HTTP Server (Port 8080)
<a href=#running-the-http-server-port-8080>#</a></h5><p>The HTTP server will serve the HTML page at the root route. Open a terminal and run:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>uvicorn main:app --host 0.0.0.0 --port <span style=color:#2aa198>8080</span>
</span></span></code></pre></div><h5 class=heading id=running-the-websocket-server-port-8081>Running the WebSocket Server (Port 8081)
<a href=#running-the-websocket-server-port-8081>#</a></h5><p>The WebSocket server will handle real-time communication. Open another terminal and run:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>uvicorn web_socket:app --host 0.0.0.0 --port <span style=color:#2aa198>8081</span>
</span></span></code></pre></div><h5 class=heading id=why-different-ports>Why Different Ports?
<a href=#why-different-ports>#</a></h5><p>We’re running the HTTP server on port 8080 and the WebSocket server on port 8081 because:</p><ul><li><span class=span_highlight>Separation of Concerns:</span> Keeps HTTP and WebSocket traffic isolated.</li><li><span class=span_highlight>Easier Debugging:</span> If something goes wrong, you know exactly where to look.</li><li><span class=span_highlight>Scalability:</span> Makes it easier to scale and load balance in the future.</li></ul><p>And hey, if you’re curious about the pros and cons of running them on the same port, stay tuned for a future blog post (because who doesn’t love a good sequel?).</p><h4 class=heading id=step-3-verify-everything-is-working>Step 3: Verify Everything is Working
<a href=#step-3-verify-everything-is-working>#</a></h4><p>Let’s make sure everything is set up correctly.</p><ul><li>Open <span class=span_highlight><a href=http://localhost:8080>http://localhost:8080</a></span> in your browser. You should see the chat interface.</li><li>Check the Network Tab in developer tools <span class=span_highlight>(F12)</span>. Look for a WebSocket connection to <span class=span_highlight><a href=ws://localhost:8081/ws>ws://localhost:8081/ws</a></span> with status 101 Switching Protocols.</li><li>Type you message and submit, In the terminal running the WebSocket server, you should see logs like:</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>INFO: WebSocket connection established
</span></span><span style=display:flex><span>INFO: Received: AnonymousABC: Hello!
</span></span><span style=display:flex><span>INFO: Sent: AnonymousABC: Hello!
</span></span></code></pre></div><h4 class=heading id=step-4-making-the-chat-bidirectional-because-talking-to-yourself-is-weird>Step 4: Making the Chat Bidirectional (Because Talking to Yourself is Weird)
<a href=#step-4-making-the-chat-bidirectional-because-talking-to-yourself-is-weird>#</a></h4><p>Right now, our chat app is like a monologue—you send a message, and it echoes back to you. But let’s be honest, talking to yourself is only fun for so long. To fix this, we’ll:</p><ul><li><span class=span_highlight>Track all connected users:</span> So the server knows who’s chatting.</li><li><span class=span_highlight>Broadcast messages:</span> So everyone in the group can see them (because group chats are where the drama happens).</li></ul><h5 class=heading id=create-a-connection-manager>Create a Connection Manager
<a href=#create-a-connection-manager>#</a></h5><p>This guy will keep track of who’s connected and broadcast messages like a town crier.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#586e75># connection_manager.py</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> fastapi <span style=color:#719e07>import</span> WebSocket
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> typing <span style=color:#719e07>import</span> List
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>ConnectionManager</span>:
</span></span><span style=display:flex><span>    <span style=color:#719e07>def</span> __init__(<span style=color:#268bd2>self</span>):
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>active_connections: List[WebSocket] <span style=color:#719e07>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>connect</span>(<span style=color:#268bd2>self</span>, websocket: WebSocket):
</span></span><span style=display:flex><span>        <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>accept()
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>active_connections<span style=color:#719e07>.</span>append(websocket)
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;INFO: New connection. Total connections: </span><span style=color:#2aa198>{</span><span style=color:#b58900>len</span>(<span style=color:#268bd2>self</span><span style=color:#719e07>.</span>active_connections)<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>def</span> <span style=color:#268bd2>disconnect</span>(<span style=color:#268bd2>self</span>, websocket: WebSocket):
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>active_connections<span style=color:#719e07>.</span>remove(websocket)
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;INFO: Connection removed. Total connections: </span><span style=color:#2aa198>{</span><span style=color:#b58900>len</span>(<span style=color:#268bd2>self</span><span style=color:#719e07>.</span>active_connections)<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>broadcast</span>(<span style=color:#268bd2>self</span>, message: <span style=color:#b58900>str</span>):
</span></span><span style=display:flex><span>        <span style=color:#719e07>for</span> connection <span style=color:#719e07>in</span> <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>active_connections:
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> connection<span style=color:#719e07>.</span>send_text(message)
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;INFO: Broadcasted: </span><span style=color:#2aa198>{</span>message<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
</span></span></code></pre></div><h5 class=heading id=update-the-websocket-endpoint>Update the WebSocket Endpoint
<a href=#update-the-websocket-endpoint>#</a></h5><p>Now, the server will broadcast messages to everyone, not just the sender.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#586e75># web_socket.py</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> fastapi <span style=color:#719e07>import</span> FastAPI, WebSocket
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> connection_manager <span style=color:#719e07>import</span> ConnectionManager
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#719e07>=</span> FastAPI()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>manager <span style=color:#719e07>=</span> ConnectionManager()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>@app.websocket</span>(<span style=color:#2aa198>&#34;/ws&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>websocket_endpoint</span>(websocket: WebSocket):
</span></span><span style=display:flex><span>    <span style=color:#719e07>await</span> manager<span style=color:#719e07>.</span>connect(websocket)
</span></span><span style=display:flex><span>    <span style=color:#719e07>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#719e07>while</span> <span style=color:#cb4b16>True</span>:
</span></span><span style=display:flex><span>            data <span style=color:#719e07>=</span> <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>receive_text()
</span></span><span style=display:flex><span>            <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;INFO: Received: </span><span style=color:#2aa198>{</span>data<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> manager<span style=color:#719e07>.</span>broadcast(data)  <span style=color:#586e75># Send to everyone</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>except</span> <span style=color:#cb4b16>Exception</span> <span style=color:#719e07>as</span> e:
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;ERROR: </span><span style=color:#2aa198>{</span>e<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#719e07>finally</span>:
</span></span><span style=display:flex><span>        manager<span style=color:#719e07>.</span>disconnect(websocket)
</span></span></code></pre></div><p>Now your chat app is fully functional and ready for some real-time drama. Next up: scaling it like a pro. Stay tuned!</p><h4 class=heading id=step-5-how-far-can-we-go-with-this-setup>Step 5: How Far Can We Go with this setup?
<a href=#step-5-how-far-can-we-go-with-this-setup>#</a></h4><p>Our current setup uses a simple <code>ConnectionManager</code> to handle WebSocket connections and broadcast messages. But how many users can it handle before things start falling apart? Let’s do some math and find out.</p><h5 class=heading id=back-of-the-envelope-calculations>Back-of-the-Envelope Calculations
<a href=#back-of-the-envelope-calculations>#</a></h5><p><b>Memory Usage</b></p><ul><li>Each WebSocket connection consumes ~10 KB of memory (this can vary based on the server and framework).</li><li>If your server has 8 GB of RAM available for the app:</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Total connections = Total RAM / Memory per connection
</span></span><span style=display:flex><span>Total connections = 8 GB / 10 KB = 800,000 connections
</span></span></code></pre></div><p>But wait! This is just memory. In reality, CPU and network limits will kick in much earlier.</p><p><b>CPU Usage</b></p><ul><li>Broadcasting a message to N users requires O(N) CPU operations.</li><li>If you have 1,000 users and each sends 10 messages per second:</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Messages per second = 1,000 users * 10 messages = 10,000 messages/second
</span></span></code></pre></div><p><b>Network Bandwidth</b>
If each message is 100 bytes, and you have 1,000 users sending 10 messages per second:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Bandwidth = 1,000 users * 10 messages * 100 bytes = 1 MB/s
</span></span></code></pre></div><p>This is manageable for now, but as users grow, bandwidth becomes a bottleneck.</p><p><b>Practical Limits</b></p><ul><li><span class=span_highlight>Single Server:</span> With 4 CPU cores and 8 GB RAM, you can handle ~1,000–2,000 concurrent users before performance degrades.</li><li><span class=span_highlight>Bottlenecks:</span><ul><li>CPU struggles with broadcasting.</li><li>Memory fills up as connections grow.</li><li>Network bandwidth becomes a limiting factor.</li></ul></li></ul><p><b>What Happens When You Hit the Limit?</b></p><ul><li><span class=span_highlight>Latency:</span> Messages take longer to deliver.</li><li><span class=span_highlight>Timeouts:</span> New connections may fail.</li><li><span class=span_highlight>Crashes:</span> The server might run out of memory or CPU.</li></ul><p><b>What If You’re Running the HTTP Server on the Same Machine?</b></p><ul><li>The HTTP server will share the same CPU, memory, and network resources.</li><li>This reduces the available resources for WebSocket connections, lowering the practical limit to ~500–1,000 concurrent users.</li></ul><p>Without these, you’re stuck with the limits of a single server. In the next section, we’ll explore scaling with Redis. Stay tuned!</p><h2 class=heading id=scaling-up-handling-moderate-traffic>Scaling Up: Handling Moderate Traffic
<a href=#scaling-up-handling-moderate-traffic>#</a></h2><p>Our current setup can handle ~1,000–2,000 users, but what if your app goes viral? (Hey, we can dream, right?) Let’s scale things up with Redis.</p><h4 class=heading id=why-redis>Why Redis?
<a href=#why-redis>#</a></h4><p>Redis is an in-memory data store that’s perfect for:</p><ul><li>Storing WebSocket connections: Track users across multiple servers.</li><li>Pub/Sub Messaging: Broadcast messages efficiently.</li><li>Scalability: Handle thousands of connections without breaking a sweat.</li></ul><h4 class=heading id=lets-add-redis-connection-manager>Let&rsquo;s Add Redis Connection Manager
<a href=#lets-add-redis-connection-manager>#</a></h4><p>We’ll create a singleton Redis connection to manage WebSocket connections and messages.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#586e75># reddis_connection_manager.py</span>
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> redis.asyncio <span style=color:#719e07>import</span> Redis
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> json
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> fastapi <span style=color:#719e07>import</span> WebSocket
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> typing <span style=color:#719e07>import</span> Dict
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> uuid
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>RedisConnectionManager</span>:
</span></span><span style=display:flex><span>    <span style=color:#719e07>def</span> __init__(<span style=color:#268bd2>self</span>):
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>redis <span style=color:#719e07>=</span> Redis(host<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;localhost&#34;</span>, port<span style=color:#719e07>=</span><span style=color:#2aa198>6379</span>, db<span style=color:#719e07>=</span><span style=color:#2aa198>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#586e75># Generate a unique ID for this server instance</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>server_id <span style=color:#719e07>=</span> <span style=color:#b58900>str</span>(uuid<span style=color:#719e07>.</span>uuid4())
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>connect</span>(<span style=color:#268bd2>self</span>, websocket: WebSocket, client_id: <span style=color:#b58900>str</span>):
</span></span><span style=display:flex><span>        <span style=color:#2aa198>&#34;&#34;&#34;Register new WebSocket connection in Redis&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>accept()
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75># Store client info in Redis</span>
</span></span><span style=display:flex><span>        client_data <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>            <span style=color:#2aa198>&#39;server_id&#39;</span>: <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>server_id,
</span></span><span style=display:flex><span>            <span style=color:#2aa198>&#39;client_id&#39;</span>: client_id,
</span></span><span style=display:flex><span>            <span style=color:#2aa198>&#39;timestamp&#39;</span>: asyncio<span style=color:#719e07>.</span>get_event_loop()<span style=color:#719e07>.</span>time()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75># Use Redis pipeline for atomic operations</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>async</span> <span style=color:#719e07>with</span> <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>redis<span style=color:#719e07>.</span>pipeline(transaction<span style=color:#719e07>=</span><span style=color:#cb4b16>True</span>) <span style=color:#719e07>as</span> pipe:
</span></span><span style=display:flex><span>            <span style=color:#586e75># Add to active clients set</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> pipe<span style=color:#719e07>.</span>sadd(<span style=color:#2aa198>&#39;active_clients&#39;</span>, client_id)
</span></span><span style=display:flex><span>            <span style=color:#586e75># Store client metadata</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> pipe<span style=color:#719e07>.</span>hset(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#39;client:</span><span style=color:#2aa198>{</span>client_id<span style=color:#2aa198>}</span><span style=color:#2aa198>&#39;</span>, mapping<span style=color:#719e07>=</span>client_data)
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> pipe<span style=color:#719e07>.</span>execute()
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;Client </span><span style=color:#2aa198>{</span>client_id<span style=color:#2aa198>}</span><span style=color:#2aa198> connected to server </span><span style=color:#2aa198>{</span><span style=color:#268bd2>self</span><span style=color:#719e07>.</span>server_id<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75># Start message listener for this client</span>
</span></span><span style=display:flex><span>        asyncio<span style=color:#719e07>.</span>create_task(<span style=color:#268bd2>self</span><span style=color:#719e07>.</span>_client_listener(websocket, client_id))
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>disconnect</span>(<span style=color:#268bd2>self</span>, client_id: <span style=color:#b58900>str</span>):
</span></span><span style=display:flex><span>        <span style=color:#2aa198>&#34;&#34;&#34;Remove client from Redis&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>async</span> <span style=color:#719e07>with</span> <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>redis<span style=color:#719e07>.</span>pipeline(transaction<span style=color:#719e07>=</span><span style=color:#cb4b16>True</span>) <span style=color:#719e07>as</span> pipe:
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> pipe<span style=color:#719e07>.</span>srem(<span style=color:#2aa198>&#39;active_clients&#39;</span>, client_id)
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> pipe<span style=color:#719e07>.</span>delete(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#39;client:</span><span style=color:#2aa198>{</span>client_id<span style=color:#2aa198>}</span><span style=color:#2aa198>&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> pipe<span style=color:#719e07>.</span>execute()
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;Client </span><span style=color:#2aa198>{</span>client_id<span style=color:#2aa198>}</span><span style=color:#2aa198> disconnected from server </span><span style=color:#2aa198>{</span><span style=color:#268bd2>self</span><span style=color:#719e07>.</span>server_id<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>broadcast</span>(<span style=color:#268bd2>self</span>, message: <span style=color:#b58900>dict</span>):
</span></span><span style=display:flex><span>        <span style=color:#2aa198>&#34;&#34;&#34;Broadcast message to all active clients&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        message_str <span style=color:#719e07>=</span> json<span style=color:#719e07>.</span>dumps(message)
</span></span><span style=display:flex><span>        <span style=color:#719e07>await</span> <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>redis<span style=color:#719e07>.</span>publish(<span style=color:#2aa198>&#39;broadcast_channel&#39;</span>, message_str)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>_client_listener</span>(<span style=color:#268bd2>self</span>, websocket: WebSocket, client_id: <span style=color:#b58900>str</span>):
</span></span><span style=display:flex><span>        <span style=color:#2aa198>&#34;&#34;&#34;Listen for messages intended for this specific client&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        pubsub <span style=color:#719e07>=</span> <span style=color:#cb4b16>None</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span>:
</span></span><span style=display:flex><span>            pubsub <span style=color:#719e07>=</span> <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>redis<span style=color:#719e07>.</span>pubsub()
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> pubsub<span style=color:#719e07>.</span>subscribe(<span style=color:#2aa198>&#39;broadcast_channel&#39;</span>)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#719e07>while</span> <span style=color:#cb4b16>True</span>:
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span>:
</span></span><span style=display:flex><span>                    message <span style=color:#719e07>=</span> <span style=color:#719e07>await</span> pubsub<span style=color:#719e07>.</span>get_message(ignore_subscribe_messages<span style=color:#719e07>=</span><span style=color:#cb4b16>True</span>)
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> message <span style=color:#719e07>and</span> message[<span style=color:#2aa198>&#34;type&#34;</span>] <span style=color:#719e07>==</span> <span style=color:#2aa198>&#34;message&#34;</span>:
</span></span><span style=display:flex><span>                        <span style=color:#586e75># Check if client is still active</span>
</span></span><span style=display:flex><span>                        is_active <span style=color:#719e07>=</span> <span style=color:#719e07>await</span> <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>redis<span style=color:#719e07>.</span>sismember(<span style=color:#2aa198>&#39;active_clients&#39;</span>, client_id)
</span></span><span style=display:flex><span>                        <span style=color:#719e07>if</span> <span style=color:#719e07>not</span> is_active:
</span></span><span style=display:flex><span>                            <span style=color:#719e07>break</span>
</span></span><span style=display:flex><span>                            
</span></span><span style=display:flex><span>                        <span style=color:#586e75># Forward message to WebSocket</span>
</span></span><span style=display:flex><span>                        <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>send_text(message[<span style=color:#2aa198>&#34;data&#34;</span>]<span style=color:#719e07>.</span>decode())
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>                <span style=color:#719e07>except</span> <span style=color:#cb4b16>Exception</span> <span style=color:#719e07>as</span> e:
</span></span><span style=display:flex><span>                    <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;Error sending to client </span><span style=color:#2aa198>{</span>client_id<span style=color:#2aa198>}</span><span style=color:#2aa198>: </span><span style=color:#2aa198>{</span>e<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
</span></span><span style=display:flex><span>                    <span style=color:#719e07>break</span>
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                <span style=color:#719e07>await</span> asyncio<span style=color:#719e07>.</span>sleep(<span style=color:#2aa198>0.01</span>)
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>        <span style=color:#719e07>finally</span>:
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> pubsub:
</span></span><span style=display:flex><span>                <span style=color:#719e07>await</span> pubsub<span style=color:#719e07>.</span>unsubscribe()
</span></span><span style=display:flex><span>                <span style=color:#719e07>await</span> pubsub<span style=color:#719e07>.</span>close()
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>disconnect(client_id)
</span></span></code></pre></div><h4 class=heading id=update-the-websocket-endpoint-1>Update the WebSocket Endpoint
<a href=#update-the-websocket-endpoint-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#586e75># web_socket.py</span>
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> fastapi <span style=color:#719e07>import</span> FastAPI, WebSocket, WebSocketDisconnect
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> redis_conn_manager <span style=color:#719e07>import</span> RedisConnectionManager
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#719e07>=</span> FastAPI()
</span></span><span style=display:flex><span>redis_manager <span style=color:#719e07>=</span> RedisConnectionManager()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>@app.websocket</span>(<span style=color:#2aa198>&#34;/ws&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>websocket_endpoint</span>(websocket: WebSocket):
</span></span><span style=display:flex><span>    client_id <span style=color:#719e07>=</span> <span style=color:#b58900>str</span>(<span style=color:#b58900>id</span>(websocket))
</span></span><span style=display:flex><span>    <span style=color:#719e07>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#719e07>await</span> redis_manager<span style=color:#719e07>.</span>connect(websocket, client_id)
</span></span><span style=display:flex><span>        <span style=color:#719e07>while</span> <span style=color:#cb4b16>True</span>:
</span></span><span style=display:flex><span>            data <span style=color:#719e07>=</span> <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>receive_text()
</span></span><span style=display:flex><span>            message <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>                <span style=color:#2aa198>&#34;client_id&#34;</span>: client_id,
</span></span><span style=display:flex><span>                <span style=color:#2aa198>&#34;server_id&#34;</span>: redis_manager<span style=color:#719e07>.</span>server_id,
</span></span><span style=display:flex><span>                <span style=color:#2aa198>&#34;message&#34;</span>: data
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>await</span> redis_manager<span style=color:#719e07>.</span>broadcast(message)
</span></span><span style=display:flex><span>    <span style=color:#719e07>except</span> WebSocketDisconnect:
</span></span><span style=display:flex><span>        <span style=color:#719e07>await</span> redis_manager<span style=color:#719e07>.</span>disconnect(client_id)
</span></span><span style=display:flex><span>    <span style=color:#719e07>except</span> <span style=color:#cb4b16>Exception</span> <span style=color:#719e07>as</span> e:
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;Error handling websocket: </span><span style=color:#2aa198>{</span>e<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#719e07>await</span> redis_manager<span style=color:#719e07>.</span>disconnect(client_id)
</span></span></code></pre></div><p>Use this in the html response for the root page</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span> <span style=color:#586e75>// Generate a random username (e.g., &#34;AnonymousXYZ&#34;)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#268bd2>const</span> generateUsername <span style=color:#719e07>=</span> () =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#268bd2>const</span> randomPart <span style=color:#719e07>=</span> <span style=color:#b58900>Math</span>.random().toString(<span style=color:#2aa198>36</span>).substring(<span style=color:#2aa198>2</span>, <span style=color:#2aa198>5</span>).toUpperCase();
</span></span><span style=display:flex><span>      <span style=color:#719e07>return</span> <span style=color:#586e75>`Anonymous - </span><span style=color:#2aa198>${</span>randomPart<span style=color:#2aa198>}</span><span style=color:#586e75>`</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>const</span> username <span style=color:#719e07>=</span> generateUsername(); <span style=color:#586e75>// Assign a random username
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#268bd2>const</span> ws <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> WebSocket(<span style=color:#2aa198>&#34;ws://localhost:8081/ws&#34;</span>);
</span></span><span style=display:flex><span>          
</span></span><span style=display:flex><span>  ws.onopen <span style=color:#719e07>=</span> () =&gt; {
</span></span><span style=display:flex><span>      console.log(<span style=color:#2aa198>&#34;WebSocket connected ✅&#34;</span>);
</span></span><span style=display:flex><span>      ws.send(username); <span style=color:#586e75>// Send the username first
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  };
</span></span><span style=display:flex><span>  ws.onerror <span style=color:#719e07>=</span> (event) =&gt; {
</span></span><span style=display:flex><span>      console.error(<span style=color:#2aa198>&#34;WebSocket error ❌:&#34;</span>, event);
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#586e75>// Function to send a message
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#268bd2>const</span> sendMessage <span style=color:#719e07>=</span> () =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#268bd2>const</span> message <span style=color:#719e07>=</span> <span style=color:#b58900>document</span>.getElementById(<span style=color:#2aa198>&#34;message&#34;</span>).value.trim();
</span></span><span style=display:flex><span>      <span style=color:#719e07>if</span> (message <span style=color:#719e07>===</span> <span style=color:#2aa198>&#34;&#34;</span>) <span style=color:#719e07>return</span>; <span style=color:#586e75>// Prevent sending empty messages
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>      ws.send(<span style=color:#586e75>`</span><span style=color:#2aa198>${</span>message<span style=color:#2aa198>}</span><span style=color:#586e75>`</span>);
</span></span><span style=display:flex><span>      <span style=color:#b58900>document</span>.getElementById(<span style=color:#2aa198>&#34;message&#34;</span>).value <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;&#34;</span>; <span style=color:#586e75>// Clear the input box
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#586e75>// Display incoming messages
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  ws.onmessage <span style=color:#719e07>=</span> (event) =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#268bd2>const</span> messages <span style=color:#719e07>=</span> <span style=color:#b58900>document</span>.getElementById(<span style=color:#2aa198>&#34;messages&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#268bd2>const</span> li <span style=color:#719e07>=</span> <span style=color:#b58900>document</span>.createElement(<span style=color:#2aa198>&#34;li&#34;</span>);
</span></span><span style=display:flex><span>      console.log(event.data);
</span></span><span style=display:flex><span>      li.textContent <span style=color:#719e07>=</span> event.data;
</span></span><span style=display:flex><span>      messages.appendChild(li);
</span></span><span style=display:flex><span>  };
</span></span></code></pre></div><h4 class=heading id=code-breakdown>Code Breakdown
<a href=#code-breakdown>#</a></h4><p>Let&rsquo;s dive into how our distributed chat system actually works (without the fluff):</p><p><b>Connection Setup</b></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>connect</span>(<span style=color:#268bd2>self</span>, websocket: WebSocket, client_id: <span style=color:#b58900>str</span>):
</span></span></code></pre></div><ul><li>Each new connection gets a unique ID</li><li>Redis stores this in two places: <code>active_clients</code> set and <code>client:{id}</code> hash (their personal details)</li><li>No storing connections in memory, for single server you can do that python memory, but that won&rsquo;t scale</li></ul><p><b>Message Broadcasting</b></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>broadcast</span>(<span style=color:#268bd2>self</span>, message: <span style=color:#b58900>dict</span>):
</span></span></code></pre></div><ul><li>Takes a message and publishes to Redis channel</li><li>Like shouting in a room, but more sophisticated</li><li>Redis handles the heavy lifting of message distribution</li></ul><p><b>The Magic Listener</b></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>_client_listener</span>(<span style=color:#268bd2>self</span>, websocket: WebSocket, client_id: <span style=color:#b58900>str</span>):
</span></span></code></pre></div><ul><li>Each client gets their own listener (personal DJ if you will)</li><li>Subscribes to Redis channel</li><li>Forwards messages to the right WebSocket</li><li>Dies gracefully when connection drops (RIP)</li></ul><p><b>Disconnection</b></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>disconnect</span>(<span style=color:#268bd2>self</span>, client_id: <span style=color:#b58900>str</span>):
</span></span></code></pre></div><ul><li>Removes client from Redis sets and hashes</li><li>Like checking out of a hotel, but we actually clean up after ourselves</li></ul><h4 class=heading id=scaling-with-redis-math-edition>Scaling with Redis (Math Edition)
<a href=#scaling-with-redis-math-edition>#</a></h4><p>Let’s compare our Python ConnectionManager with Redis and see how Redis saves the day.</p><p><b>Python ConnectionManager</b></p><ul><li><span class=span_highlight>Memory:</span> Each WebSocket connection consumes ~10 KB. 8 GB RAM → ~800,000 connections (theoretically).</li><li><span class=span_highlight>CPU:</span> Broadcasting to N users requires O(N) operations. 1,000 users sending 10 messages/second = 10,000 messages/second (CPU cries).</li><li><span class=span_highlight>Practical Limit: </span>~1,000–2,000 users (CPU and memory choke), due to event loop limitations and GIL.</li></ul><p><b>Redis to the Rescue</b></p><ul><li><span class=span_highlight>Memory:</span> Redis stores only metadata and Pub/Sub references, reducing its per-connection memory footprint.
8 GB → 800,000 connections assumption is rough but fair for estimation.
However, in practice, network buffers and additional metadata would slightly reduce this number.</li><li><span class=span_highlight>CPU:</span> Redis Pub/Sub is not O(N) but significantly optimised. Internally, Redis Pub/Sub still
needs to push messages to each subscriber. However, redis minimizes context switching, optimizes memory access, and efficiently handles large numbers of subscribers compared to a Python-based event loop.</li><li><span class=span_highlight>Practical Limit:</span> ~10,000–20,000 concurrent users, (Redis flexes its muscles) but
this depends on message frequency and server configuration.
Some deployments (with Redis Cluster, Sentinel, or sharding) scale far beyond this.</li></ul><p><b>Why Redis Wins</b></p><ul><li><span class=span_highlight>Optimized Broadcasting:</span> Pub/Sub efficiently delivers messages with minimal latency.</li><li><span class=span_highlight>Scalable Architecture:</span> Supports clustering and sharding for handling massive user loads.</li><li><span class=span_highlight>Lower CPU Overhead:</span> Offloads message distribution from the application server.</li><li><span class=span_highlight>High Throughput:</span> Handles thousands of messages per second with minimal performance loss.</li><li><span class=span_highlight>Reliable Scaling:</span> Works with load balancers and multiple Redis instances for redundancy.</li></ul><p>This setup lets us scale horizontally - just add more servers like adding more pizza to a party.
Each server is independent but they all work together through Redis, like a well-oiled machine (that runs on caffeine). That&rsquo;s it! No memory leaks, no server drama, just clean, scalable code!</p><h2 class=heading id=the-dream-scale-handling-thousands-of-users>The Dream Scale: Handling Thousands of Users
<a href=#the-dream-scale-handling-thousands-of-users>#</a></h2><p>Now that we’ve scaled with Redis, let’s dream bigger. What if your app goes viral and needs to handle thousands (or millions) of users? Enter RabbitMQ (and friends).</p><h4 class=heading id=why-rabbitmq>Why RabbitMQ?
<a href=#why-rabbitmq>#</a></h4><p>RabbitMQ is a message broker designed for:</p><ul><li><span class=span_highlight>High Throughput:</span> Handles millions of messages per second.</li><li><span class=span_highlight>Message Queuing:</span> Ensures no messages are lost, even under heavy load.</li><li><span class=span_highlight>Complex Routing:</span> Supports advanced routing patterns (e.g., fanout, direct, topic).</li></ul><p>If your app needs:</p><ul><li>Guaranteed message delivery.</li><li>Complex message routing.</li><li>High throughput (millions of messages/second).
RabbitMQ is your go-to tool.</li></ul><h4 class=heading id=back-of-the-envelope-calculations-1>Back-of-the-Envelope Calculations
<a href=#back-of-the-envelope-calculations-1>#</a></h4><p><b>Redis:</b></p><ul><li>Handles ~10,000–20,000 users comfortably.</li><li>Great for real-time broadcasting and simple Pub/Sub.</li><li>Bottleneck: CPU and memory on a single server.</li></ul><p><b>RabbitMQ:</b></p><ul><li>Handles millions of messages/second.</li><li>Uses disk-based storage for messages, ensuring reliability.</li><li>Scales horizontally with clusters.</li></ul><p><b>Practical Limits:</b></p><ul><li>Single RabbitMQ Server: ~50,000–100,000 users.</li><li>RabbitMQ Cluster: Millions of users (distributed across multiple servers).</li></ul><h4 class=heading id=rabbitmq-connection-manager>RabbitMQ Connection Manager
<a href=#rabbitmq-connection-manager>#</a></h4><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#586e75># rabbitmq_connection_manager.py</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> pika
</span></span><span style=display:flex><span><span style=color:#719e07>import</span> json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>class</span> <span style=color:#268bd2>RabbitMQManager</span>:
</span></span><span style=display:flex><span>    <span style=color:#719e07>def</span> __init__(<span style=color:#268bd2>self</span>):
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>connection <span style=color:#719e07>=</span> pika<span style=color:#719e07>.</span>BlockingConnection(pika<span style=color:#719e07>.</span>ConnectionParameters(<span style=color:#2aa198>&#34;localhost&#34;</span>))
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>channel <span style=color:#719e07>=</span> <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>connection<span style=color:#719e07>.</span>channel()
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>channel<span style=color:#719e07>.</span>exchange_declare(exchange<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;chat&#34;</span>, exchange_type<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;fanout&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>def</span> <span style=color:#268bd2>publish</span>(<span style=color:#268bd2>self</span>, message):
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>channel<span style=color:#719e07>.</span>basic_publish(exchange<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;chat&#34;</span>, routing_key<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;&#34;</span>, body<span style=color:#719e07>=</span>json<span style=color:#719e07>.</span>dumps(message))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>def</span> <span style=color:#268bd2>consume</span>(<span style=color:#268bd2>self</span>, callback):
</span></span><span style=display:flex><span>        result <span style=color:#719e07>=</span> <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>channel<span style=color:#719e07>.</span>queue_declare(queue<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;&#34;</span>, exclusive<span style=color:#719e07>=</span><span style=color:#cb4b16>True</span>)
</span></span><span style=display:flex><span>        queue_name <span style=color:#719e07>=</span> result<span style=color:#719e07>.</span>method<span style=color:#719e07>.</span>queue
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>channel<span style=color:#719e07>.</span>queue_bind(exchange<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;chat&#34;</span>, queue<span style=color:#719e07>=</span>queue_name)
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>channel<span style=color:#719e07>.</span>basic_consume(queue<span style=color:#719e07>=</span>queue_name, on_message_callback<span style=color:#719e07>=</span>callback, auto_ack<span style=color:#719e07>=</span><span style=color:#cb4b16>True</span>)
</span></span><span style=display:flex><span>        <span style=color:#268bd2>self</span><span style=color:#719e07>.</span>channel<span style=color:#719e07>.</span>start_consuming()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#586e75># web_socket.py</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> fastapi <span style=color:#719e07>import</span> FastAPI, WebSocket
</span></span><span style=display:flex><span><span style=color:#719e07>from</span> rabbitmq_connection_manager <span style=color:#719e07>import</span> RabbitMQManager
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#719e07>=</span> FastAPI()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis_manager <span style=color:#719e07>=</span> RabbitMQManager()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>@app.websocket</span>(<span style=color:#2aa198>&#34;/ws&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#719e07>async</span> <span style=color:#719e07>def</span> <span style=color:#268bd2>websocket_endpoint</span>(websocket: WebSocket):
</span></span><span style=display:flex><span>    <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>accept()
</span></span><span style=display:flex><span>    redis_manager<span style=color:#719e07>.</span>subscribe(<span style=color:#2aa198>&#34;chat&#34;</span>)  <span style=color:#586e75># Subscribe to the &#34;chat&#34; channel</span>
</span></span><span style=display:flex><span>    username <span style=color:#719e07>=</span> <span style=color:#cb4b16>None</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>try</span>:
</span></span><span style=display:flex><span>      <span style=color:#586e75># Receive the username from the frontend</span>
</span></span><span style=display:flex><span>        username <span style=color:#719e07>=</span> <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>receive_text()
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;INFO: </span><span style=color:#2aa198>{</span>username<span style=color:#2aa198>}</span><span style=color:#2aa198> connected&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#719e07>while</span> <span style=color:#cb4b16>True</span>:
</span></span><span style=display:flex><span>            data <span style=color:#719e07>=</span> <span style=color:#719e07>await</span> websocket<span style=color:#719e07>.</span>receive_text()
</span></span><span style=display:flex><span>            redis_manager<span style=color:#719e07>.</span>publish(<span style=color:#2aa198>&#34;chat&#34;</span>, {<span style=color:#2aa198>&#34;user&#34;</span>: username, <span style=color:#2aa198>&#34;message&#34;</span>: data})
</span></span><span style=display:flex><span>    <span style=color:#719e07>except</span> <span style=color:#cb4b16>Exception</span> <span style=color:#719e07>as</span> e:
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;ERROR: </span><span style=color:#2aa198>{</span>e<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#719e07>finally</span>:
</span></span><span style=display:flex><span>        redis_manager<span style=color:#719e07>.</span>pubsub<span style=color:#719e07>.</span>unsubscribe(<span style=color:#2aa198>&#34;chat&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#b58900>print</span>(<span style=color:#2aa198>f</span><span style=color:#2aa198>&#34;INFO: </span><span style=color:#2aa198>{</span>username<span style=color:#2aa198>}</span><span style=color:#2aa198> disconnected&#34;</span>)
</span></span></code></pre></div><h4 class=heading id=managed-services-vs-self-hosted>Managed Services vs. Self-Hosted
<a href=#managed-services-vs-self-hosted>#</a></h4><p><b>Managed Services:</b></p><ul><li>Pros: No setup hassle, automatic scaling, and maintenance.</li><li>Examples: Google Pub/Sub, AWS SQS, Azure Service Bus.</li></ul><p><b>Self-Hosted:</b></p><ul><li>Pros: Full control, great for learning, and cost-effective for small to medium apps.</li><li>Cons: You handle scaling, maintenance, and troubleshooting.</li></ul><p><b>Why Self-Hosted?</b></p><p>If you’re like me and enjoy solving problems (and occasionally crying over server logs), self-hosting RabbitMQ is a great learning opportunity. Plus, it’s satisfying to see your app scale!</p><h2 class=heading id=conclusion-real-time-apps-made-simple>Conclusion: Real-Time Apps Made Simple
<a href=#conclusion-real-time-apps-made-simple>#</a></h2><p>Building real-time apps requires the right balance of speed, scalability, and reliability. A Python-based connection manager works for small apps but struggles under heavy load. Redis Pub/Sub efficiently scales WebSockets but lacks message persistence. For guaranteed delivery, RabbitMQ or managed pub/sub services are the best choices.</p><p>Choose Redis for speed, RabbitMQ for reliability, or a hybrid approach for the best of both worlds. 🚀</p><h4 class=heading id=what-are-your-thoughts>What Are Your Thoughts?
<a href=#what-are-your-thoughts>#</a></h4><p>Real-time scalability is an evolving challenge, and every use case is unique. Which approach has worked best for you? Have you faced scaling challenges with WebSockets? Share your experiences, insights, or questions in the comments below! 👇</p><script src=https://giscus.app/client.js data-repo=rjsnh1522/blog_comments data-repo-id=R_kgDONp-vFw data-category data-category-id=DIC_kwDONp-vF84Cl_FD data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/engineering/own_your_work/>Own Your Work</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/engineering/securing_websocket_connections/>Securing the websocket connection</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>